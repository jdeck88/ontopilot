#
# Provides high-level management of build targets.  Associates build target
# classes with sets of command-line argument name/value pairs and returns an
# instance of the appropriate build target after inspecting command-line
# argument values.
#

# Python imports.
import abc
from collections import namedtuple

# Java imports.


# Define a simple "struct"-like type for associating build target classes with
# sets of command-line argument name/value pairs.  The members are:
#   tclass: The target class.
#   argvals (dict): A dictionary of argname/value pairs.
TargetMap = namedtuple('TargetMap', 'tclass, argvals')


class BuildTargetManager:
    """
    Manages build targets.  Build targets are associated with sets of
    command-line argument name/value pairs, and when a matching set of
    arguments is passed in by client code, the associated target is
    instantiated and returned.
    """
    def __init__(self):
        # The list of build target mappings.
        self.targetmaps = []

    def addBuildTarget(self, targetclass, **argvals):
        """
        Adds a build target mapping.

        targetclass: The class of the build target.
        argvals: Command-line argument values to map to the target.  These
            should be passed as keyword arguments.
        """
        targetmap = TargetMap(tclass=targetclass, argvals=argvals)
        self.targetmaps.append(targetmap)

    def _getBuildTargetNames(self, argname, **argvals):
        """
        Returns a list of valid build target names.  The names are generated by
        inspecting the value of a given command-line argument.

        argname: The command-line argument from which to generate the name
            values.
        argvals: Additional argument values, specified as keyword arguments, to
            use as constraints when generating the list of target names.
        """
        tnames = set()
        for tmap in self.targetmaps:
            if argname in tmap.argvals:
                # Check if the argument value constraints also match.
                constraints_match = True
                for name in argvals:
                    if name in tmap.argvals:
                        if argvals[name] != tmap.argvals[name]:
                            constraints_match = False
                    else:
                        constraints_match = False

                if constraints_match:
                    tnames.add(tmap.argvals[argname])

        tnames_l = list(tnames)
        tnames_l.sort()

        return tnames_l

    def getBuildTargetNamesStr(self, argname, **argvals):
        """
        Returns a string containing the valid build target names.  The names
        are generated by inspecting the value of a given command-line argument.

        argname: The command-line argument from which to generate the name
            values.
        argvals: Additional argument values, specified as keyword arguments, to
            use as constraints when generating the list of target names.
        """
        tnames = self._getBuildTargetNames(argname, **argvals)

        names_str = ''
        if len(tnames) == 1:
            names_str = '"' + tnames[0] + '"'
        elif len(tnames) == 2:
            names_str = '"' + '" or "'.join(tnames) + '"'
        elif len(tnames) > 2:
            names_str = '"' + '", "'.join(tnames[:len(tnames) - 1]) + '", '
            names_str += 'or "' + tnames[-1] + '"'

        return names_str

    def _getMatchingTargets(self, args):
        """
        Returns a list of all target maps that match the specified argment
        values.  Supports partial matching of string values.  The target maps
        are returned sorted in descending order by the number of matching
        arguments.

        args: A "struct" of command-line argument names and values.  Typically
            obtained from ArgumentParser.
        """
        matches = []

        for targetmap in self.targetmaps:
            # Count the total number of matching argument values.
            matching_argcnt = 0
            for argname in targetmap.argvals:
                # Check if the attribute exists in the provided argument set.
                # Using hasattr() would require less code, but doesn't work
                # well with properties.
                has_arg = True
                argval = None
                try:
                    argval = getattr(args, argname)
                except AttributeError:
                    has_arg = False

                if has_arg:
                    if isinstance(argval, basestring):
                        argval = argval.strip()
                        if (
                            argval != '' and
                            targetmap.argvals[argname].startswith(argval)
                        ):
                            matching_argcnt += 1
                    elif targetmap.argvals[argname] == argval:
                        matching_argcnt += 1

            if matching_argcnt == len(targetmap.argvals):
                matches.append(targetmap)

        # Sort the target maps by the number of matching arguments.
        matches.sort(
            key=lambda targetmap: len(targetmap.argvals), reverse=True
        )

        return matches

    def _getAmbiguousTargetErrorMsg(self, args, matches, tname_arg):
        """
        Tries to a generate a helpful error message for cases where the
        specified arguments do not unambiguously map to a single build target.

        args: A "struct" of command-line argument names and values.  Typically
            obtained from ArgumentParser.
        matches: A list of all matching target mappings.
        tname_arg: the name of the argument that contains the main build
            target/task name.  If a non-empty value is provided, all argument
            sets must include this argument.
        """
        errormsg = ''
        if tname_arg != '':
            # Check if all matching target names are the same.  If so, then the
            # ambiguity is due to additional arguments.
            sametname = True
            tname = matches[0].argvals[tname_arg]
            for match in matches:
                if match.argvals[tname_arg] != tname:
                    sametname = False

            if not(sametname):
                tnames = list(set(
                    [tmapping.argvals[tname_arg] for tmapping in matches]
                ))
                tnames.sort()
                tnames_str = '"' + '", "'.join(tnames) + '"'
                errormsg = (
                    'The specified build task, "{0}", matched more than one '
                    'build task name.  Please provide the full build task '
                    'name (or enough characters to disambiguate it).  The '
                    'following tasks matched: {1}.'.format(
                        getattr(args, tname_arg), tnames_str
                    )
                )
            else:
                errormsg = (
                    'The arguments for the build task "{0}" could not be '
                    'unambiguously matched to a single build operation.  '
                    'Please check the argument values.'.format(tname)
                )
        else:
            errormsg = (
                'The command-line arguments could not be unambiguously '
                'matched to a single build operation.  Please check the '
                'argument values.'
            )

        return errormsg

    def getBuildTarget(self, args, targetname_arg=''):
        """
        Returns an instance of the specified build target.  In the case that
        more than one target matches the provided command-line argument values,
        targets with the greatest number of command-line argument mappings will
        be matched first (that is, more specific target specifications will be
        matched before more general target specifications).

        args: A "struct" of command-line argument names and values.  Typically
            obtained from ArgumentParser.
        targetname_arg: The name of the argument that contains the main build
            target/task name.  This is used only for generating useful error
            messages.  If a non-empty value is provided, all argument sets must
            include this argument.
        """
        # Gather all target maps with matching argument name/value sets.
        matches = self._getMatchingTargets(args)

        targetmatch = None
        if len(matches) > 1:
            # Attempt to dis-ambiguate the target specification.  The matching
            # target maps will already be in descending order sorted by the
            # number of matching arguments, so we just need to see if the first
            # match has more arguments than the next.
            if len(matches[0].argvals) > len(matches[1].argvals):
                targetmatch = matches[0]
            else:
                raise RuntimeError(
                    self._getAmbiguousTargetErrorMsg(args, matches, targetname_arg)
                )
        elif len(matches) == 1:
            targetmatch = matches[0]
        else:
            if targetname_arg != '':
                errormsg = (
                    'Unknown build target: "{0}".  Valid build target names '
                    'are: {1}.'.format(
                        getattr(args, targetname_arg),
                        self.getBuildTargetNamesStr(targetname_arg)
                    )
                )
            else:
                errormsg = (
                    'Argument values could not be matched to a build target.'
                )

            raise RuntimeError(errormsg)

        target = targetmatch.tclass(args)

        return target

